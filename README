動作環境は、Cygwin, Mac

コンパイルオプションは、gcc -std=c99 -O3 -march=core2 -o solver など

■slide_pazzle.rb

ソルバーは与えた一問を解答して、特定のフォーマットで返すだけのモノなので、
実際に5000問を保持して、ソルバーを叩く為のプログラム

* 解答済みをスキップできる機能
* ソルバーから帰ってきた解答が、正しいかどうかの検証を行う機能
* 解答済みをスキップしない場合に解答を作成する機能

■merge_answer.rb

複数の別種のソルバーの結果を混ぜて、最も効率のいい手を提出できるように抜き出すプログラム

* 解答を作成する機能

■solver: ベース
solver_ida_md_2.c が一番基本となる、オーソドックスなソース
* 再帰を用いた IDA*
* MD(壁考慮済み)
* 局面を 64bit ハッシュ化 (将棋などで用いられる手法・・・？)
* 64bit ハッシュとちょっとした局面情報(depthなど)を 2^23 の一次インデックス(配列)と2^26の二次ヒープ(リンクドリスト)で保存する
* 終局局面から逆順に、400万手順を寄せテーブルとしてハッシュに保存。最終20手番ほどまで来ればこの段階でヒットできる
  寄せテーブルはキューを使った幅優先で作成

■sovler: 乱数を使った枝刈り
solver_ida_md_2_mdcut3.c は乱数を使って枝刈りを行う

* MDが増加する場合、乱数で 25% の局面をカットする枝刈り

意外にこれだけでかなりの解答が出てしまった。

■solver: 分割統治
solver_ida_md_3.c は分割統治できるようにしてみた

* 一番上の行と左の列がそろったらそこは崩さないように修正
* 上記の状態になったら、レジューム用のデータを出力
  ※例えば、6,6 の局面を、一番上と左を削って 5,5 の局面に再生成する
  ※再生成した局面データと、そこに至る解答をレジューム用データとして出力する

pazzle_resume.rb

* レジューム用データを元に、再度ソルバーを叩く

思ったよりも効果が発揮できなかった


